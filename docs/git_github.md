# バージョン管理 Git/GitHub

## 最低限の要素

- バージョン管理の必要性
- Git 入門: リポジトリ、コミット、ブランチ
- GitHub CLI
- **演習**: リポジトリの作成、コミット、ブランチの作成・削除、イシューの作成、プルリクエスト

## 方針

- 各段階で完結して開発出来るようになる
- 問題を起こしやすい機能はできる限り後で紹介

## 現状気になっていること

- 履歴間の移動とfeatureブランチの活用はバージョン管理の本質かも
  - `git diff`出来るだけでも嬉しいは嬉しいのだが。。
- developブランチは古臭い？
  - 最近のオープンソースで良くあるブランチ運用だと見ないことも多いかも
- GitHub CLIの話も
  - 公開鍵不要で`gh auth login`すれば済むのはでかい
  - `clone, pull, push`も`gh repo clone, sync`で行ける
    - ただし、`gh repo clone`したら`git pull`できない

## 入門編: とりあえず使い始める

- バージョン管理とgit
  - 原始的な管理: ディレクトリに日付や番号をつけて管理
  - より現代的な管理: gitをはじめとするバージョン管理システムの利用
- 基本的なコマンド
  - リポジトリの作成: `init`
  - ファイルの追加: `add <files>`
    - 空ディレクトリは無視される
  - 変更されたファイルの確認: `status`
  - 変更されたファイルの差分: `diff`
  - 履歴の記録: `commit <files>`
    - 環境変数の設定: `EDITOR`
  - 履歴の閲覧: `log`
  - 履歴の比較: `diff [<hash>]`
    - コラム: (gitじゃない)普通の`diff`コマンドも便利
githubを使ってみよう
  - バックアップの重要性: 物理的に異なる場所へ
  - githubとgitは違うもの
  - リモートリポジトリとローカルリポジトリ
  - リモートリポジトリの作成
  - ローカルリポジトリへのリモートリポジトリの登録:
    - `remote add <remote_branch> <remote_url>`
    - リモートリポジトリにはローカル上での任意の名前をつけられる
  - 追跡ブランチの登録: `branch -u <remote_branch>`
    - `branch`コマンドの別の使い方 => 初級編へ
  - リモートリポジトリへの記録: `push`
  - 不要なファイルは登録しない: `.gitignore`
  - いろんな場所で作業したいときもリモートリポジトリが便利
  - リモートリポジトリのコピー: `clone <remote_url> [<path>]`
  - 別の場所での作業の反映: `pull`
    - conflictと言われたら？ => マージが必要(初級編へ)
- gitの設定方法: `~/.gitconfig`、`~/.gitignore`、`./.git`、`./.gitignore`
  - リポジトリごとの設定: `./.git`、`./.gitignore`
  - 自分用の共通設定: `~/.gitconfig`、`~/.gitignore`
- 運用: ローカルmain=リモートmain、ブランチは一本
- コラム: ディレクトリによるプロジェクト管理とプロジェクトルート、最近のエディタの機能

## 基礎編: 個人開発

- 安定版と開発版を分離しよう: 複数のブランチの必要性
  - 利用するときは常に安定版を利用
  - 開発は開発用のブランチで続ける
- ブランチ状態の確認: `branch`、`branch -r`、`branch -a`
- ブランチの作成: `branch <new_branch>`
  - ブランチの作成&移動: `branch -b <new_branch>`
- 追跡ブランチはローカルブランチごとに登録可能: `branch -u <remote_branch>`
  - 習慣: ブランチを作成したらすぐに必ず追跡ブランチを指定する
    - 例外: ライフタイムがローカルで完結するブランチ
  - 習慣: リモートブランチ名はローカルの同名ブランチの追跡ブランチに必ず対応させる
  - 習慣: `push`や`pull`は引数なしで使う
- 別のブランチへの移動: `switch <another_branch>`
- コンフリクトとマージ
  - コンフリクトさせてみよう
  - ファイル履歴衝突の解消: `merge`
    - 注意: 複数ファイルにまたがる不整合は解消出来ない => テストの重要性
- ブランチツリーの確認: `log --tree`
- 運用: mainブランチとdevelopブランチの並行運用
  - 利点: コードを活発に開発しつつ、信頼できる最新版を保持
  - 利点: mainのlogが見やすくなって、バージョン間の違いが明確
  - main: 安定版、コードを実際に利用するときはmainの最新版
  - develop: 開発版、開発するときはdevelopの最新版
  - 注釈: なぜfeature(短ライフタイム)でなくdevelop(長ライフタイム)か
    - 個人開発だとfeatureブランチ(1度に追加する機能の数)は1本(=develop)で済むことが多い
    - 開発版もリモートへバックアップしたい
      - 習慣: 1日の終わりに必ずpushする
    - featureブランチはブランチ削除が頻繁に発生するため事故の原因
      - 逆に削除を忘れて汚くなったりもする
    - 複数のリモートブランチの追跡という概念への習熟
- コラム: もう使わないコマンド `checkout` (`restore`、`switch`を使う)

## 発展編: もっと便利に個人開発、共同開発してみよう

- テストの自動化
  - 継続的インテグレーション(CI/CD)  
  - テスト、フォーマッタ、ドキュメント生成、デプロイ、パッケージング
  - gitコマンドに紐づいた自動実行: `git-hook`
  - リモート側での自動実行（Github action等）
- オープンソースへ貢献しよう
  - フォーク: `fork`
  - イシュー・プルリクエストの書き方
  - イシュー・プルリクエストのライフサイクル
  - Github Wikiの活用
  - ライセンスの設定: 公開時は必須、ないと使いたい人が困る
- 注意して使うべき機能
  - マージ(説明済み)
  - ブランチの削除: `branch -d <branch>`
  - 特定の履歴への移動: `restore`
- featureブランチの活用
  - 共同開発ならfeatureブランチを切るのが自然
  - とはいえいずれ消すからローカルに切れば十分
  - featureブランチのライフタイムはできる限り短くする
- 特定の履歴への移動: `restore`
  - 今いる場所: `HEAD`
  - 直近の変更の取り消し: `restore HEAD`
  - 過去の履歴への移動: `restore -s <hash>`
  - 過去の履歴から別の修正を行いたい場合:
    - HEADの移動、featureブランチ作成、開発、マージ、featureブランチ削除
  - 過去に戻れるのがバージョン管理の良いところだが、過去に戻ると履歴がコンフリクトしやすいので注意
- 使わないで済むならなら使わないほうが良い機能: `revert`、`reset`
  - 過去のコミット履歴の編集・削除
  - リモートリモートリポジトリへpushしてしまうと更に避けるべき
  - 大抵は`restore`、`branch`、`merge`で済む
- 使わないで済むならなら使わないほうが良い機能: `rebase`
  - コミット履歴をきれいにしたいために使う
  - リモートリモートリポジトリへpushしたコミットへ適用するとひどいことになる
  - マージで十分
- 様々なブランチ運用: プロジェクトごとの方針で決まる
  - 一般的な注意: ブランチ管理(ブランチ作成・削除、コンフリクト解消)はコストを伴う(脳が疲れる)
    - やらないで済むならやらないほうが良い。単純な方が新人も分かりやすい。
    - ブランチは最小限に。
    - マージ方向は一方向に。
    - 開発者・ユーザが増えた時にやむを得ず必要になるのが複雑なブランチ運用
  - Git flow: 堅い業務開発用というイメージ、少人数だと管理コストがかさむので不向き
  - Github flow: main+feature、少人数でも有効なブランチ運用
  - CPythonの場合: mainブランチ+サポート中の各マイナーバージョンのブランチ
    - mainブランチ: 開発用
    - マイナーバージョンのブランチ: 安定版、バグの修正のため
    - これも研究で継続的に固定バージョンを使いたい場合に便利(タグ付けだとバグ修正が大変)
- タグ: `tag <tag>`、`push --tag`、`show <tag>`
  - 過去の特定のバージョンを番号として指定したい場合に便利
  - ハッシュだと覚えるのが大変(とはいえそれで済むならそれでも良い)
  - タグは複数のブランチをまたがって一覧表示可能(複数バージョン管理時にも便利)
- コラム: バージョン番号の付け方とインターフェースの互換性
  - 番号: `v<major>.<minor>.<patch>`
  - `<patch>`: バグの修正のみ
  - `<minor>`: 後方互換性のある機能追加
  - `<major>`: 後方互換性のない機能追加・削除
  - ただし、なんだかんだでマイナーバージョンが違うと動かないことはある。。基本姿勢として。
