# プロセスの操作

## プロセスとは

コンピュータでプログラムを実行すると、メモリ上にそのプログラムの実行状態が作られます。この実行中のプログラムの実体を **プロセス** と呼びます。

- 実行ファイルとプロセス: ディスクに保存されている実行ファイル（例: /bin/ls）がプログラムとして実行されると、Linuxはプログラムの実行に必要な情報を取りまとめた「プロセス」と呼ばれるデータ構造をコンピュータのメモリ内に生成します。
- プロセスID (PID): 各プロセスには、OSによって一意の識別番号であるプロセスID（PID）が割り当てられます。同じプログラムから複数のプロセスを同時に生成することも可能で（例: ls コマンドを複数のターミナルで同時に実行する）、この場合は同じ名前のプログラムは異なるPIDを持ちます。
- 独立性: 各プロセスは、基本的には他のプロセスから独立したメモリ空間やリソース（CPU時間、ファイルなど）を持ちます。
- シェルとの関係: 私たちがターミナルでコマンドを入力すると、シェルがそのコマンドに対応するプログラムを実行し、新しいプロセスを生成します。

## Linuxのプロセスツリー

Linuxでは、これらのプロセスは1つの親プロセス (`init`プロセスや `systemd` など、PIDが1のプロセス) から派生しており、親子関係を持つツリー状の構造になっています。

- 各プロセスには固有のプロセスID（PID）が付与されます。
- 親プロセスが必ず存在し、子プロセスは親プロセスから環境変数などを引き継ぐことが出来ます。

```bash
$ ps           # プロセスの一覧を表示
$ ps -f        # フル形式で親子関係を含めて表示
$ pstree       # プロセスのツリー構造を表示
```

よく見るプロセスの例:

- 対話型シェル（`bash` など）
- 実行中のコマンド（`ls`, `cat`, `sleep` など）
- デーモン（バックグラウンドサービス）

## フォアグラウンドとバックグラウンドの切り替え `jobs`、`fg`、`bg`、`Ctrl-Z`

ターミナルで起動したプロセスは通常「フォアグラウンド」で動作します。

- `Ctrl-Z`: 現在のジョブを一時停止
- `bg`: 停止中のジョブをバックグラウンドで再開
- `fg`: ジョブをフォアグラウンドに戻す
- `jobs`: ジョブの一覧を表示

```bash
$ sleep 100
# 100秒以内にCtrl-Z で停止
$ jobs
$ bg           # バックグラウンドで再開
$ jobs
$ fg           # フォアグラウンドに戻す

$ sleep 100 &  # コマンドの最後に&をつけると最初からバックグラウンド
$ jobs
```

## リモートでプロセスの実行を続けるには `nohup`、`screen`、`tmux`

リモート接続（SSHなど）を切ってもプロセスを生かしたい場合は、次のいずれかの方法で実現できます。

まず、`nohup`を使うとログアウト後もプロセスを継続できる。

```bash
client$ ssh <server_name>
$ bash -c "sleep 30 && echo Finished at `date` > tmp.txt" &
$ exit    # ログアウトするとスクリプトの実行プロセスは途中で停止

client$ ssh <server_name>
$ nohup bash -c "sleep 30 && echo Finished at `date` > tmp.txt" &
$ exit    # 30秒以内にログアウトしてもプロセスは継続
client$ ssh <server_name>
$ cat tmp.txt
```

`screen`や`tmux`はターミナルマルチプレクサと呼ばれ、リモート接続切断後もプロセス維持できます。分割画面や切断したセッションへの再接続も可能です。

```bash
$ tmux           # 新しいセッションを開始
$ tmux attach    # 切断したセッションに再接続
```

### `scfront`上で重い処理を実行しない

`scfront`は重い処理を実行することを想定されておらず、`screen`や`tmux`はインストールされていません。実際にデータ解析や数値シミュレーションを実行する場合はIDLノードや計算ノードを利用してください。

## プロセスの確認・停止・強制終了 `ps`、`kill`、`killall`

```bash
$ ps aux                # 詳細なプロセス一覧
$ ps l -u <user>        # <user>が実行したプロセス一覧

$ kill <PID>            # 対象プロセスを終了
$ kill -9 <PID>         # 強制終了（SIGKILL）

$ killall <process>     # 名前が <process> のプロセスを全て終了
$ killall -9 <process>  # 名前が <process> のプロセスを全て強制終了
```

プロセスの状態を確認しながら、安全に停止させる習慣をつけましょう。

## プロセスの停止忘れに要注意

通常、SSH接続が切れるとそのセッションで実行したプロセスも自動で停止します。
しかし、通信切断によりSSH接続が切れた後も子プロセスが残り続け、他ユーザーの利用を妨げる場合があります。
その場合、`ps`で確認しながら手動で`kill`する必要があります。
`nohup`やターミナルマルチプレクサを利用すると、プロセスの停止を忘れる危険性は更に上がります。
できる限り正常にセッション・プロセスを終了する習慣をつけましょう。

## **演習**: プロセスの生成と削除

以下の操作を実際に試して、プロセスの生成・確認・終了の流れを体験してください。

(1) `sleep` コマンドをバックグラウンドで実行する:

```bash
$ sleep 60 &  # 60秒を計測して何もせず終了するプロセスをバックグラウンドで実行
```

(2) `ps` または `jobs` で確認する:

```bash
$ ps
$ jobs
```

(3) プロセスIDを調べて `kill` で終了させる:

```bash
$ kill <PID>
```
